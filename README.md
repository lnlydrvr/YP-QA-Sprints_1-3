# Проекты по курсу "Инженер по тестированию: от новичка до автоматизатора" от Яндекс Практикум

![Лого Яндекс Практикум](yandex_practicum_logo.png)

## Описание

В этом репозитории находятся решения проектов по части автоматизации тестирования, выполненных в рамках курса "Инженер по тестированию: от новичка до автоматизатора".

В качестве языка программирования выбран Python.

Репозиторий создан специально для синхронизации проектов между разными ПК.

## Содержание

- [Требования](#требования)
- [Структура репозитория](#структура-репозитория)
- [Задачи по репозиторию](#задачи-по-репозиторию)
- [Задания проектов](#задания-проектов)
    - [1 спринт автоматизации "Основый Python"](#1-спринт-автоматизации-основы-python)
    - [2 спринт автоматизации "ООП: наследование, полиморфизм](#2-спринт-автоматизации-ооп-наследование-полиморфизм)

## Требования

Список необходимых инструментов и библиотек для работы с проектами:

- Python 3.10 и выше
- любой текстовый редактор или IDE

## Структура репозитория

```
qa_yandex_practicum/
├── qa_python_1/        # 1 спринт автоматизации "Основы Python"
│   ├── additional_task_1.py
│   ├── additional_task_2.py
│   ├── task_1.py
│   ├── task_2.py
│   ├── task_3.py
│   ├── task_4.py
│   └── task_5.py
├── qa_python_2/        # 2 спринт автоматизации "ООП: наследование, полиморфизм"
│   ├── task_1.py
│   ├── task_2.py
│   ├── task_3.py
│   ├── task_4.py
│   └── task_5.py
├── README.md       # Описание репозитория
└── yandex_practicum_logo.png       # Лого Яндекс Практикум
```

## Задачи по репозиторию

- [ ] Написать README.md файл
- [ ] Решить [дополнительное задание 1](qa_python_1/additional_task_1.py) в спринте "Основы Python"

## Задания проектов

### 1 спринт автоматизации "Основы Python"

#### Задание 1

Строка содержит пять временных значений. Они записаны через запятую:

```'1h 45m,360s,25m,30m 120s,2h 60s'```.

Напиши цикл, который посчитает общее количество минут. Результат сохрани в переменную и выведи на экран. Используй в решении методы ```split()```, ```replace()``` и оператор ```in```.

Обрати внимание: временное значение может состоять из одного, двух или трёх единиц времени. Значения расшифровываются так:

- часы — любое положительное целое число и символ ```h```;
- минуты — любое положительное целое число и символ ```m```;
- секунды — положительное целое число кратное 60 и символ ```s```.

#### Задание 2

Исправь класс ```Tester``` так, чтобы:

- при вызове метода ```work_hard``` у экземпляра класса ```tester_1``` печаталось ```'tester_1 Можно отдыхать'```;
- при вызове метода ```work_hard``` у экземпляра класса ```tester_2``` печаталось ```'tester_2 Что ж, ещё часок поработаю!'```.

Вызовы менять не нужно.

Прекод:

```python
class Tester:

    def __init__(name):
        name = name
        deadline = True

    def work_hard(self, deadline=True):
        if self.deadline:
            print(self.name, 'Что ж, ещё часок поработаю!')
        else:
            print(self.name, 'Можно отдыхать')

tester_1 = Tester(name='tester_1')
tester_1.work_hard(deadline=False)  # 'tester_1 Можно отдыхать'
tester_2 = Tester(name='tester_2')
tester_2.work_hard(deadline=True)   # 'tester_2 Что ж, ещё часок поработаю!'
```

#### Задание 3

Словарь содержит информацию о чемпионатах по футболу в 21 веке:

- год. Например, 1988;
- страна, которая выиграла чемпионат мира по футболу. Например, Англия.

Что нужно сделать:

1. Добавь в словарь 2022 год. В 2022 году чемпионом стала Аргентина.
2. Выведи на экран всех чемпионов в формате ```год - страна```.
3. Проверь, выигрывала ли Италия в 21 веке. Есть переменная ```country``` со значением ```Италия```. Проверь, содержится ли она в словаре. Если да, выведи надпись ```Италия cтановилась чемпионом мира по футболу в 21 веке!```. А если страна отсутствует среди значений словаря, выведи на экран ```Италия не выигрывала чемпионат мира по футболу в 21 веке```.

Прекод:

```python
world_champions = {
    2002: 'Бразилия',
    2006: 'Италия',
    2010: 'Испания',
    2014: 'Германия',
    2018: 'Франция',
}

...

country = 'Италия'

...
```

#### Задание 4

Есть два списка задач. Список ```new_tasks``` содержит задачи, которые по плану нужно протестировать до конца месяца. Список ```completed_tasks``` — уже завершенные в текущем месяце.

Что нужно сделать:

1. Тестировщик только что завершил задачу ```task_005```. Перенеси её из списка ```new_tasks``` в список ```completed_tasks```. Сделай это в одно действие.
2. Запрос ```task_007``` заказчик убрал из плана, потому что нужно доработать требования. Удали его из списка ```new_tasks```.
3. В последней задаче из списка ```new_tasks``` заказчик поднял приоритет, поэтому её нужно будет взять в работу следующей. Выведи её на экран.

Прекод:
```python
new_tasks = ['task_001', 'task_011', 'task_007', 'task_015', 'task_005']
completed_tasks = ['task_002', 'task_012', 'task_006']
```

#### Задание 5

Напиши класс ```TestCase```. Он должен содержать конструктор и методы.

В конструкторе инициализируются поля:

- ```steps``` — шаги тест-кейса, в качестве параметра принимает пустой словарь;
- ```result``` — ожидаемый результат выполнения тест-кейса, принимает ```None``` в качестве параметра.

Методы:

- Метод ```set_step``` — добавляет в словарь ```steps``` шаг тест-кейса. Принимает два параметра: ```step_number``` и ```step_text```. Ключ — это ```step_number``` (номер шага), а значение — ```step_text``` (текстовое описание шага).
- Метод ```delete_step``` — удаляет шаг из ```steps``` по ключу ```step_number```, который передали в метод.
- Метод ```set_result``` — устанавливает ожидаемый результат. Он помещает его в атрибут ```result``` по параметру ```result```, который передали методу.
- Метод ```get_test_case``` — печатает информацию о составе тест-кейса в формате ```{'Шаги': {<номер шага>: '<описание шага>'}, 'Ожидаемый результат': '<вывод ожидаемого результата>'}```.

Пример вывода метода ```get_test_case```:

```python
{
    'Шаги': {
            1: 'Перейти на сайт', 
            2: 'Перейти в раздел Товары', 
            3: 'Нажать кнопку «В корзину» у первого товара'
    }, 
    'Ожидаемый результат': 'Товар окажется в корзине'
}
```

Прекод:

```python
class TestCase:

    def __init__(self):
   ...
   ...

test_case_1 = TestCase()
test_case_1.set_step(1, 'Перейти на сайт')
test_case_1.set_step(3, 'Перейти в раздел Товары')
test_case_1.delete_step(3)
test_case_1.set_step(2, 'Перейти в раздел Товары')
test_case_1.set_step(3, 'Нажать кнопку «В корзину» у первого товара')
test_case_1.set_result('Товар окажется в корзине')
test_case_1.get_test_case()

test_case_2 = TestCase()
test_case_2.set_step(1, 'Перейти на сайт')
test_case_2.set_step(2, 'Перейти в раздел Корзина')
test_case_2.set_step(3, 'Нажать кнопку "Удалить"')
test_case_2.set_result('Товар удален из корзины')
test_case_2.get_test_case()
```

#### Дополнительное задание 1

В словаре ```types``` хранятся типы багов. Его ключи — числа от 1 до 5, а значения — от ```'Блокирующий'``` до ```'Тривиальный'``` соответственно.

```python
types = {
    1: 'Блокирующий',
    2: 'Критический',
    3: 'Значительный',
    4: 'Незначительный',
    5: 'Тривиальный'
}
```

В словаре ```tickets``` хранятся тикеты (задачи), которые заведены на эти баги. Ключи — числовое значение критичности от 1 до 5, а значения — список с тикетами, которые этим значениям критичности соответствуют. Но некоторые тикеты добавлены несколько раз в разные списки.

```python
tickets = {
    1: ['API_45', 'API_76', 'E2E_4'],
    2: ['UI_19', 'API_65', 'API_76', 'E2E_45'],
    3: ['E2E_45', 'API_45', 'E2E_2'],
    4: ['E2E_9', 'API_76'],
    5: ['E2E_2', 'API_61']
}
```

Составь итоговый словарь, где ключи — это значение критичности, например ```'Значительный'```, а значения — списки с уникальными тикетами. 

Для этого напиши две функции: 

- одна удаляет дубли из списков с тикетами,
- вторая связывает уровень критичности со списком уникальных тикетов.

Если тикет есть в одном списке, то он уже не может быть в списках на уровень ниже. 

Вторая функция принимает на вход два параметра: словарь ```types``` с типами багов и словарь ```tickets``` со списком багов. Функция возвращает словарь, где уровень критичности связан со списком уникальных тикетов.

Итоговый словарь должен получиться таким:

```python
tickets_by_type = {
    'Блокирующий': ['API_45', 'API_76', 'E2E_4'],
    'Критический': ['UI_19', 'API_65', 'E2E_45'],
    'Значительный': ['E2E_2'],
    'Незначительный': ['E2E_9'],
    'Тривиальный': ['API_61']
}
```

Вызывать функцию необязательно.

#### Дополнительное задание 2

Напиши функцию, которая рассчитывает цифровой корень числа. 

Чтобы получить числовой корень числа, нужно:

1. Первоначальное число разбить на цифры по разрядам.
2. Сложить эти цифры.
3. С суммой сделать то же самое: разбить на цифры и сложить их.
4. И так — пока не получится одна цифра (от 1 до 9), которая и будет цифровым корнем числа.

Например, числовой корень числа 4851 — 9.

- 4851 → 4+8+5+1 = 18
- 18 → 1+8 = 9

Цифровой корень 97569 равен 9:

- 97569 → 9+7+5+6+9 = 36
- 36 → 3+6 = 9

Пример посложнее. Для числа 889987 цифровой корень — 4:

- 889987 → 8+8+9+9+8+7= 49
- 49 → 4+9 = 13
- 13 → 4

Функцию можно назвать ```digit_root(num)```. Она принимает на вход один параметр — ```num``` (число), а возвращает цифровой корень.

Условия: 

- входное число натуральное (1, 2, 3, … );
- число не превышает $10^7$

### 2 спринт автоматизации "ООП: наследование, полиморфизм"

#### Задание 1

> В этом задании тебе нужно создать подвид тест-кейса.

Есть класс ```Case```. Он содержит метод ```print_test_case_info()```, который выводит на экран ```id``` тест-кейса, его название, описание шага, ожидаемый результат.

Что тебе нужно сделать:

1. Создай подкласс ```ExtendedCase```. Он наследует все атрибуты из класса ```Case```. Кроме того, добавь ему два новых атрибута через конструктор — ```precondition``` и ```environment```. Тип данных для них — строки.
2. Вызови метод ```__init__()``` суперкласса. Используй функцию ```super()```.
3. Переопредели метод ```print_test_case_info()``` в классе ```ExtendedCase```. Он должен печатать:

    - все атрибуты суперкласса;
    - новые атрибуты подкласса в формате ```"Предусловие: {precondition}"``` и ```Окружение: {environment}"```. Каждый атрибут нужно вывести с новой строки.

4. Создай объект ```case``` класса ```ExtendedCase```. Входные параметры такие: ```('1', 'Наличие кнопки Принять', '1. Открыть вкладку приёма документов 2. Проверить наличие кнопки ', 'Кнопка доступна', 'Открыть сервис', 'Яндекс Браузер')```.

Вызови метод ```print_test_case_info()``` для объекта ```casе```.

Прекод:
```python
class Case:
    def __init__(self, test_case_id, name, step_description, expected_result):
        self.test_case_id = test_case_id
        self.name = name
        self.step_description = step_description
        self.expected_result = expected_result

    def print_test_case_info(self):
        print(f"ID тест-кейса:  {self.test_case_id}"
              f"\nНазвание: {self.name}"
              f"\nОписание шага: {self.step_description}"
              f"\nОжидаемый результат: {self.expected_result}")

... # напиши свой код здесь
```

Подсказки:

1. Конструктор суперкласса через ```super()``` выглядит так: ```super().__init__(name)```. Указывать имя суперкласса не нужно.
2. Чтобы данные выводились с новой строки, используй ```\n```. Например, ```f"\nПредусловие:  {self.precondition}"```.
3. Чтобы вывести все атрибуты суперкласса и добавить ему свои, используй ```super()```.

#### Задание 2

> В этом задании тебе нужно создать иерархию разных видов фильмов: драму и комедию, которые наследуются от суперкласса ```Movies```.

1. Создай класс ```Movies```:
    - проинициализируй в нём пустой список ```self.movies``` через конструктор;
    - добавь метод ```add_movie()```. Он будет принимать параметр ```movie``` и добавлять его в конец списка ```self.movies```.
2. Создай два дочерних класса — ```Comedy``` и ```Drama```. Они наследуют метод ```add_movie()```. Метод этих классов должен принимать параметр ```movie``` и добавлять его в конец списка ```self.movies```. Затем возвращать записи вида ```Комедии: '[]'``` и ```Драмы: '[]'``` соответственно.
3. Вызови метод ```add_movie()``` для объекта ```Comedy()```. Входной параметр — ```'Большой куш'```. Выведи на экран результат.
4. Вызови метод ```add_movie()``` для объекта ```Drama()```. Входной параметр — ```'Оружейный барон'```. Выведи на экран результат.

Прекод:

```python
class Movies:
    ...
... # напиши свой код здесь
```

Подсказки:

1. Чтобы добавить элемент в конец списка, нужен метод ```append()```. То есть так: ```self.movies.append(movie)```.
2. Чтобы вернуть значение, используй ```return```. Понадобится вернуть значение в определённом виде: ```return f'Комедии: {self.movies}'```.

#### Задание 3

> Нужно написать три класса для спортивных соревнований — разные способы начислять спортсменам очки:
> 1. ```PointsForPlace``` — количество очков равно месту, которое занял спортсмен.
> 2. ```PointsForMeters``` — количество очков высчитывается с учётом расстояния, на которое спортсмен метнул диск.
> 3. ```TotalPoints``` — умеет работать и с местом спортсмена, и с расстоянием.

Теперь подробно:

1. Напиши класс ```PointsForPlace```. Он получает количество очков в зависимости от места, которое занял спортсмен.

В этом классе напиши метод ```get_points_for_place()```, который принимает аргумент ```place``` — целое число. Причём: 

- Если место строго больше 100, должно выводиться сообщение ```'Баллы начисляются только первым 100 участникам'```.
- Если как аргумент передали значение меньше 1, должно печататься сообщение ```'Спортсмен не может занять нулевое или отрицательное место'```.
- В остальных случаях начисляются очки по формуле: ```101 - place```.

Изначально количество очков равно нулю: подумай, как это отобразить в коде. 

Метод ```get_points_for_place()``` должен возвращать ```points```.

2. Напиши класс ```PointsForMeters```. Он рассчитывает очки в зависимости от количества метров, на которое спортсмен толкнул ядро или метнул диск: ```расстояние * 0,5```. Например, если расстояние 10 метров, спортсмен получит 5 очков.

Напиши метод ```get_points_for_meters()```, который принимает аргумент ```meters``` — целое число. Причём:

- Если количество метров меньше нуля, должно выводиться сообщение ```'Количество метров не может быть отрицательным'```.
- В остальных случаях начисляются очки по формуле: ```расстояние * 0,5```.

Метод должен возвращать ```points```. Изначально количество очков — 0.

3. Напиши класс ```TotalPoints``` для многоборцев. Он наследуется сразу от двух классов — ```PointsForPlace``` и ```PointsForMeters``` и реализует все их методы. Также он должен содержать:

    - метод ```get_total_points()```, который принимает как аргументы ```meters``` и ```place```;
    - переменную ```total```, которая суммирует значения методов ```get_points_for_place()``` и ```get_points_for_meters()```.

Метод возвращает переменную ```total```.

> Подумай, какие методы в этом задании могут быть статическими. Если метод можно сделать статическим — делай. Подумай, какая область видимости должна быть у переменной ```points``` — глобальная или локальная.

Прекод:

```python
class PointsForPlace:
    ...

class PointsForMeters:
    ...

class TotalPoints(PointsForPlace, PointsForMeters):
    ...

points_for_place = PointsForPlace()
print(points_for_place.get_points_for_place(10))

points_for_meters = PointsForMeters()
print(points_for_meters.get_points_for_meters(10))

total_points = TotalPoints()
print(total_points.get_points_for_place(10))
print(total_points.get_points_for_meters(10))
print(total_points.get_total_points(100, 10))
```

Подсказки:

- Чтобы количество очков изначально равнялось нулю, используй переменную ```points = 0```.
Внутри методов ```get_points_for_meters()``` и ```get_points_for_place()``` должны быть условные операторы. Например, для мест — ```if place > 100```, затем ```elif place < 1```.

#### Задание 4

> Напиши класс ```EmployeeSalary```. Он рассчитывает почасовую заработную плату сотрудников за неделю.

1. С помощью переменной ```hourly_payment``` установи почасовой уровень оплаты, равный ```400```.
2. Проинициализируй атрибуты ```name```, ```hours```, ```rest_days```, ```email``` через конструктор.
3. Добавь метод класса ```get_hours()```. Если значение ```hours``` неизвестно, метод рассчитывает часы, исходя из количества выходных — ```rest_days```. Формула для этого случая такая: ```(7 - rest_days) * 8```.
4. Добавь метод класса ```get_email()```. Если значение ```email``` неизвестно, метод генерирует его так: ```f"{name}@email.com"```.
5. Добавь метод класса ```set_hourly_payment()```. Он меняет значение переменной ```hourly_payment```.
6. Добавь метод расчёта заработной платы ```salary()```. Формула расчёта такая: ```hours * hourly_payment```.

Прекод:

```python
class EmployeeSalary:

    ... # напиши свой код здесь
```

Подсказки:

- У тебя будет три класс-метода. Не забудь, что им всем нужно передать ```cls``` в качестве первого аргумента.
- Метод ```get_hours()``` должен вернуть ```cls: return cls(name, hours, rest_days, email)```. Метод ```get_email()``` — аналогично. Методу ```set_hourly_payment()``` ничего возвращать не нужно, потому что он только меняет значение переменной.

#### Задание 5

> Тебе нужно создать класс, который подсчитывает результаты состязаний — ```Results```. И двух его наследников — ```Football``` и ```Hockey```. Подклассы наследуют все атрибуты, а ещё у них есть свои методы.

1. Напиши класс ```Results```. Проинициализируй в нём атрибуты ```victories```, ```draws```, ```losses``` через конструктор.
2. Напиши класс ```Football```, который наследуется от класса ```Results```. Его методы:

    - ```number_of_wins()```, который должен возвращать запись вида ```'Футбольных побед: 1'```. Количество побед должно браться из переменной ```victories```.
    - ```number_of_draws()```, который должен возвращать запись вида ```'Футбольных ничьих: 1'```. Количество ничьих должно браться из переменной ```draws```.
    - ```number_of_losses()```, который должен возвращать запись вида ```'Футбольных поражений: 1'```. Количество поражений возьми из переменной ```losses```.
    - ```total_points()```, который должен возвращать запись вида ```'Общее количество очков: 5'```. Количество очков рассчитай формуле: ```3 * количество побед + количество ничьих```.

3. Напиши класс ```Hockey```, который наследуется от класса ```Results```. Его методы:

    - ```number_of_wins()```, который должен возвращать запись вида ```'Хоккейных побед: 1'```. Количество побед метод берёт из переменной ```victories```.
    - ```number_of_draws()```, который должен возвращать запись вида ```'Хоккейных ничьих: 1'```. Количество ничьих метод берёт из переменной ```draws```.
    - ```number_of_losses()```, который должен возвращать запись вида ```'Хоккейных поражений: 1'```. Количество поражений должно браться из переменной ```losses```.
    - ```total_points()```, который должен возвращать запись вида ```'Общее количество очков: 5'```. Количество очков рассчитывается по формуле: ```2 * количество побед + количество ничьих```.

4. Создай объекты ```football_team``` и ```hockey_team``` классов ```Football``` и ```Hockey``` соответственно. В качестве параметров передай ```(2, 2, 2)```.
5. Вызови все методы для объектов ```football_team``` и ```hockey_team```. Используй цикл ```for```. Названия методов при этом не должны повторяться для обоих объектов.

Прекод:

```python
class Results:
    
... # напиши свой код здесь
```

Подсказки:
- Цикл ```for``` можно запустить сразу по двум элементам. Будет так: ```for team in (football_team, hockey_team)```. И дальше — действия.